import gzip
import os
from datetime import datetime
from math import log10

import numpy

from .fasta import read_fasta_file as readFastaFile
from .mash import runMash
from .processbar import ProcessBar


def isGzipped(file):
    openFile = open(file, 'rb')
    magicCode = openFile.read(2)
    openFile.close()
    return magicCode == b'\x1f\x8b'


def readCheckm2File(file, contamination, completeness):
    '''
    An expanded reference map of the human gut microbiome reveals hundreds of previously unknown species
    '''
    contamination *= 100
    completeness *= 100
    cluster2score = dict()
    if isGzipped(file):
        openFile = gzip.open(file, mode = 'rt')
    else:
        openFile = open(file, 'r')
    assert openFile.readline().startswith('Name\tCompleteness\tContamination\tCompleteness_Model_Used\tTranslation_Table_Used\tCoding_Density\tContig_N50'), f'\"{file}\" is not a valid output generated by CheckM2.'
    for line in openFile:
        lines = line.rstrip('\n').split('\t')
        completeness_ = float(lines[1])
        contamination_ = float(lines[2])
        if completeness_ >= completeness and contamination_ <= contamination:
            cluster2score[lines[0]] = float(lines[1]) - 5 * float(lines[2]) + 15 * log10(float(lines[6]))
    openFile.close()
    return cluster2score


def readGtdbtkFile(file):
    cluster2dpcofg_s = dict()
    if isGzipped(file):
        openFile = gzip.open(file, mode = 'rt')
    else:
        openFile = open(file, 'r')
    assert openFile.readline().startswith('user_genome\tclassification'), f'\"{file}\" is not a valid output generated by GTDB-Tk.'
    for line in openFile:
        lines = line.rstrip('\n').split('\t', maxsplit = 2)
        dpcofg, s = lines[1].rsplit(';', maxsplit = 1)
        if not dpcofg.endswith('g__'):
            cluster2dpcofg_s[lines[0]] = (dpcofg, s)
    openFile.close()
    return cluster2dpcofg_s


def createMapping(files):
    cluster2file = dict()
    for i in files:
        cluster2file[os.path.splitext(os.path.basename(i))[0]] = i
    return cluster2file


def readMashFile(nodes, file):
    n = len(nodes)
    node2index = dict((node, i) for i, node in enumerate(nodes))
    matrix = numpy.zeros(shape = (n, n), dtype = numpy.int8)
    openFile = open(file, 'r')
    for line in openFile:
        lines = line.rstrip('\n').split('\t')
        if lines[0] != lines[1]:
            nodeI = node2index[lines[0]]
            nodeJ = node2index[lines[1]]
            matrix[nodeI, nodeJ] = 1
            matrix[nodeJ, nodeI] = 1
    openFile.close()
    return matrix


def determineRepresentives(mash, mashD, mashP, mashK, mashS, cluster2file, cluster2score, cluster2dpcofg_s):
    representives = list()
    dpcofg2s2x = dict()
    for cluster in set(cluster2file.keys()) & set(cluster2score.keys()) & set(cluster2dpcofg_s.keys()):
        dpcofg_s = cluster2dpcofg_s[cluster]
        dpcofg2s2x.setdefault(dpcofg_s[0], dict()).setdefault(dpcofg_s[1], list()).append((cluster2score[cluster], cluster))
    processBar = ProcessBar(len(dpcofg2s2x))
    X = list()
    for i, (dpcofg, s2x) in enumerate(dpcofg2s2x.items(), start = 1):
        for s, x in s2x.items():
            if s != 's__':
                X.append(max(x))
                representives.append((X[-1][1], cluster2file[X[-1][1]], f'{dpcofg};{s}'))
        if 's__' in s2x:
            offset = len(X)
            s2x['s__'].sort(reverse = True)
            X.extend(s2x['s__'])
            clusterFiles = [cluster2file[i[1]] for i in X]
            tempfile = runMash(mash, mashD, mashP, mashK, mashS, clusterFiles)
            mashMatrix = readMashFile(clusterFiles, tempfile)
            os.remove(tempfile)
            y = numpy.zeros(shape = mashMatrix.shape[0], dtype = numpy.bool_)
            y[ : offset] = True
            j = 0
            for k in range(offset, y.size):
                if numpy.all(mashMatrix[k, y] == 0):
                    y[k] = True
                    representives.append((X[k][1], cluster2file[X[k][1]], f'{dpcofg};s__{j}'))
                    j += 1
        X.clear()
        processBar.plot(i)
    return representives


def writeFile(prefix, sequenceRename, x):
    openFile1 = open(f'{prefix}.annotation', 'w')
    openFile1.write('Cluster ID\tClassification\n')
    openFile2 = open(f'{prefix}.mapping', 'w')
    openFile2.write('Sequence ID\tCluster ID\n')
    openFile3 = open(f'{prefix}.assembly', 'w')
    i = 0
    for cluster, file, classification in x:
        openFile1.write(f'{cluster}\t{classification}\n')
        for sequenceID, sequence in readFastaFile(file):
            if sequenceRename:
                openFile2.write(f'{i}\t{cluster}\n')
                openFile3.write(f'>{i}\n')
                i += 1
            else:
                openFile2.write(f'{cluster}-{sequenceID}\t{cluster}\n')
                openFile3.write(f'>{cluster}-{sequenceID}\n')
            openFile3.write(sequence + '\n')
    openFile1.close()
    openFile2.close()
    openFile3.close()
    return None


def main(parameters):
    cluster2file = createMapping(parameters.fasta)
    print(f'{datetime.now().strftime("%Y-%m-%d %H:%M:%S")} -> Loading CheckM2 file.', flush = True)
    cluster2score = readCheckm2File(parameters.checkm2, parameters.contamination, parameters.completeness)
    print(f'{datetime.now().strftime("%Y-%m-%d %H:%M:%S")} -> Loading GTDB-TK file.', flush = True)
    cluster2dpcofg_s = readGtdbtkFile(parameters.gtdbtk)
    print(f'{datetime.now().strftime("%Y-%m-%d %H:%M:%S")} -> Determining representives.', flush = True)
    representives = determineRepresentives(
        parameters.mash, parameters.distance, parameters.threads, parameters.kmer_size, parameters.sketch_size,
        cluster2file, cluster2score, cluster2dpcofg_s
    )
    print(f'{datetime.now().strftime("%Y-%m-%d %H:%M:%S")} -> Writing to \"{parameters.output}.*\".', flush = True)
    writeFile(parameters.output, parameters.rename, representives)
    print(f'{datetime.now().strftime("%Y-%m-%d %H:%M:%S")} -> Finished.', flush = True)
    return None
