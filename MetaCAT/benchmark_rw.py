import gzip
from math import ceil, sqrt
from re import compile

import numpy
from matplotlib.pyplot import close, subplots

from .colors import parseRGBA

pattern = compile(r'^([^.]+)\.(.+)\.[^.]+$')


def isGzipped(file):
    openFile = open(file, 'rb')
    magicCode = openFile.read(2)
    openFile.close()
    return magicCode == b'\x1f\x8b'


def readCheckm2File(file, combine, combinedDataset):
    datasets = set()
    programs = set()
    dataset2program2scores = dict()
    if isGzipped(file):
        openFile = gzip.open(file, mode = 'rt')
    else:
        openFile = open(file, 'r')
    assert openFile.readline().startswith('Name\tCompleteness\tContamination'), f'\"{file}\" is not a valid output generated by CheckM2.'
    for line in openFile:
        lines = line.rstrip('\n').split('\t')
        matches = pattern.match(lines[0])
        assert matches, 'The 1st column must be "Dataset.Program.ClusterID", "Dataset" and "ClusterID" fields must contain no dots.'
        dataset, program = matches.groups()
        dataset = combinedDataset if combine else dataset
        datasets.add(dataset)
        programs.add(program)
        dataset2program2scores.setdefault(dataset, dict()).setdefault(program, list()).append((float(lines[1]), float(lines[2])))
    openFile.close()
    for dataset, program2scores in dataset2program2scores.items():
        for program, scores in program2scores.items():
            scores = numpy.asarray(scores, dtype = numpy.float64)
            scores /= 100
            program2scores[program] = scores
    datasets = sorted(datasets)
    programs = sorted(programs, reverse = True)
    return (datasets, programs, dataset2program2scores)


def plot(contamination, completenessSet, datasets, programs, program2label, dataset2program2scores, output, rows, columns, colors):
    nCompletenessSet = len(completenessSet)
    figure, axes = subplots(
        nrows = rows,
        ncols = columns,
        figsize = (3.5 * columns, (0.6 + 0.2 * len(programs)) * rows),
        layout = 'constrained',
        squeeze = False
    )
    for subplot in axes.flat[len(datasets) : ]:
        subplot.remove()

    x = numpy.zeros(shape = nCompletenessSet * 2, dtype = numpy.int64)
    for subplot, dataset in zip(axes.flat, datasets):
        program2scores = dataset2program2scores[dataset]
        for program in programs:
            scores = program2scores.get(program, numpy.array([[0, 1]], dtype = numpy.float64))
            contaminationMask = scores[ : , 1] <= contamination
            for i, completeness in enumerate(completenessSet):
                x[i] = numpy.count_nonzero((scores[ : , 0] >= completeness) & contaminationMask)
                yield (dataset, program, completeness, x[i])
            x[nCompletenessSet + 1 : ] = x[ : nCompletenessSet - 1]
            x[ : nCompletenessSet] -= x[nCompletenessSet : ]
            subplot.barh(program2label.get(program, program), x[ : nCompletenessSet], left = x[nCompletenessSet : ], alpha = None, height = 0.6, color = colors, linewidth = 0, label = completenessSet)
        subplot.set_title(dataset, fontdict = {'fontsize': 10}) #
        subplot.set_xlabel(f'Number of genomes (Contamination â‰¤ {contamination:.2f})', fontdict = {'fontsize': 9})
        subplot.tick_params(labelsize = 8)
        #subplot.xaxis.set_minor_locator(AutoMinorLocator(2))
        #subplot.grid(True, which = 'both', axis = 'x', linestyle = '--', linewidth = 0.5)
    figure.legend(
        completenessSet,
        ncol = nCompletenessSet,
        title = 'Completeness',
        bbox_to_anchor = (0.5, 1.0),
        loc = 'lower center',
        fontsize = 8,
        title_fontsize = 9
    )
    figure.set_constrained_layout_pads(w_pad = 0.01, h_pad = 0.01, wspace = 0.01, hspace = 0.01)
    figure.savefig(output, dpi = 300, bbox_inches = 'tight')
    close()
    return None


def main(parameters):
    parameters.contamination.sort()
    parameters.completeness.sort(reverse = True)
    colors = parseRGBA(parameters.color, len(parameters.completeness), parameters.color_min, parameters.color_max)
    datasets, programs, dataset2program2scores = readCheckm2File(parameters.checkm2, parameters.combine, parameters.combined_dataset)
    nDatasets = len(datasets)
    if parameters.rows is None and parameters.columns is None:
        parameters.columns = ceil(sqrt(nDatasets))
        parameters.rows = ceil(nDatasets / parameters.columns)
    elif parameters.rows is None:
        parameters.columns = min(parameters.columns, nDatasets)
        parameters.rows = ceil(nDatasets / parameters.columns)
    elif parameters.columns is None:
        parameters.rows = min(parameters.rows, nDatasets)
        parameters.columns = ceil(nDatasets / parameters.rows)
    else:
        assert parameters.rows * parameters.columns >= nDatasets, 'Size of grid must be greater than or equal to the number of plots.'

    program2label = dict()
    if parameters.program is not None and set(parameters.program) == set(programs):
        programs = parameters.program[ : : -1]
        if parameters.label is not None:
            program2label = dict(zip(parameters.program, parameters.label))

    datasetProgram2clusters = dict()
    for contamination in parameters.contamination:
        output = f'{parameters.output}.contamination{contamination:.2f}.pdf'
        for dataset, program, completeness, x in plot(contamination, parameters.completeness, datasets, programs, program2label, dataset2program2scores, output, parameters.rows, parameters.columns, colors):
            datasetProgram2clusters.setdefault((dataset, program2label.get(program, program)), list()).append(str(x))

    openFile = open(parameters.output + '.tsv', 'w')
    header = ['Dataset', 'Program']
    for contamination in parameters.contamination:
        for completeness in parameters.completeness:
            header.append(f'Contamination: {contamination:.2f} Completeness: {completeness:.2f}')
    openFile.write('\t'.join(header) + '\n')
    for datasetProgram, clusters in datasetProgram2clusters.items():
        clusters = '\t'.join(clusters)
        openFile.write(f'{datasetProgram[0]}\t{datasetProgram[1]}\t{clusters}\n')
    openFile.close()
    return None
